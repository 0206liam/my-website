<!DOCTYPE html>
<html lang="zh-TW">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>講稿閱讀器 - 穩定版</title>
  <style>
    :root {
      --ui-scale: 1;
    }
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }
    body {
      font-family: sans-serif;
      background: #1a1a1a;
      color: #fff;
      overflow: hidden; /* 防止整體 body 滾動 */
      width: 100vw;
      height: 100dvh;
    }
    
    /* 核心佈局：確保容器始終填滿視覺畫面 */
    #viewport-fixer {
      position: relative;
      width: 100%;
      height: 100%;
      overflow: hidden;
    }

    #container {
      display: flex;
      width: 100%;
      height: 100%;
      transition: transform 0.3s cubic-bezier(0.25, 0.46, 0.45, 0.94);
    }

    .page {
      min-width: 100vw;
      height: 100dvh;
      overflow-y: auto; /* 允許垂直滾動 */
      overflow-x: auto; /* 允許在放大時水平滾動看文字 */
      padding: 70px 20px 80px;
      -webkit-overflow-scrolling: touch;
    }

    /* UI 元件：使用 fixed 但透過 JS 動態修正位移 */
    .controls {
      position: fixed;
      top: 15px;
      right: 15px;
      z-index: 9999;
      display: flex;
      gap: 8px;
      transform-origin: top right;
    }

    .page-number {
      position: fixed;
      bottom: 20px;
      left: 50%;
      transform: translateX(-50%);
      z-index: 9999;
      background: rgba(0,0,0,0.6);
      padding: 4px 12px;
      border-radius: 15px;
      font-size: 14px;
      backdrop-filter: blur(5px);
      transform-origin: bottom center;
    }

    button {
      background: rgba(255,255,255,0.15);
      border: 1px solid rgba(255,255,255,0.3);
      color: white;
      padding: 10px 14px;
      border-radius: 8px;
      font-size: 16px;
      backdrop-filter: blur(8px);
    }

    .edit-area {
      width: 100%;
      min-height: 60dvh;
      background: #2a2a2a;
      color: #fff;
      border: 1px solid #444;
      padding: 15px;
      border-radius: 8px;
      line-height: 1.6;
      resize: none;
    }

    .page-content {
      line-height: 1.8;
      white-space: pre-wrap;
      word-wrap: break-word;
    }
  </style>
</head>
<body>

<div id="viewport-fixer">
  <div class="controls" id="ui-controls">
    <button onclick="changeFontSize(-2)">小</button>
    <button onclick="changeFontSize(2)">大</button>
    <button id="editBtn" onclick="toggleEdit()" style="background: #3498db;">✏️</button>
  </div>

  <div id="container"></div>
  
  <div class="page-number" id="ui-pagenum">1 / 1</div>
</div>

<script>
  let pages = JSON.parse(localStorage.getItem('speechPages')) || ['歡迎使用！請點擊編輯按鈕開始。', ''];
  let currentPage = 0;
  let fontSize = parseInt(localStorage.getItem('fontSize')) || 20;
  let isEditMode = false;

  // --- 解決縮放「跑掉」的核心 JS ---
  function syncUI() {
    const vv = window.visualViewport;
    if (!vv) return;

    const controls = document.getElementById('ui-controls');
    const pagenum = document.getElementById('ui-pagenum');
    
    // 抵消縮放倍率，讓按鈕看起來大小不變
    const scale = 1 / vv.scale;
    
    // 計算相對於可見視窗的位置
    const top = vv.offsetTop + (15 * scale);
    const right = (window.innerWidth - (vv.offsetLeft + vv.width)) + (15 * scale);
    const bottom = (window.innerHeight - (vv.offsetTop + vv.height)) + (20 * scale);
    const centerX = vv.offsetLeft + (vv.width / 2);

    controls.style.transform = `scale(${scale})`;
    controls.style.top = `${top}px`;
    controls.style.right = `${right}px`;

    pagenum.style.transform = `translateX(-50%) scale(${scale})`;
    pagenum.style.left = `${centerX}px`;
    pagenum.style.bottom = `${bottom}px`;
  }

  if (window.visualViewport) {
    window.visualViewport.addEventListener('resize', syncUI);
    window.visualViewport.addEventListener('scroll', syncUI);
  }

  // --- 基本功能 ---
  function render() {
    const container = document.getElementById('container');
    container.innerHTML = '';
    
    pages.forEach((content, i) => {
      const div = document.createElement('div');
      div.className = 'page';
      
      if (isEditMode) {
        const txt = document.createElement('textarea');
        txt.className = 'edit-area';
        txt.style.fontSize = fontSize + 'px';
        txt.value = content;
        txt.oninput = (e) => {
          pages[i] = e.target.value;
          if (i === pages.length - 1 && pages[i].trim() !== '') {
            pages.push('');
            render(); // 增加新頁面
          }
          localStorage.setItem('speechPages', JSON.stringify(pages));
        };
        div.appendChild(txt);
      } else {
        const p = document.createElement('div');
        p.className = 'page-content';
        p.style.fontSize = fontSize + 'px';
        p.textContent = content || (i === pages.length -1 ? '（結束）' : '（空白頁）');
        div.appendChild(p);
      }
      container.appendChild(div);
    });
    updatePos();
  }

  function updatePos() {
    const container = document.getElementById('container');
    container.style.transform = `translateX(-${currentPage * 100}vw)`;
    document.getElementById('ui-pagenum').textContent = `${currentPage + 1} / ${pages.length}`;
    syncUI();
  }

  function changeFontSize(delta) {
    fontSize = Math.max(12, Math.min(60, fontSize + delta));
    localStorage.setItem('fontSize', fontSize);
    render();
  }

  function toggleEdit() {
    isEditMode = !isEditMode;
    document.getElementById('editBtn').textContent = isEditMode ? '✓' : '✏️';
    render();
  }

  // --- 翻頁邏輯 (修正縮放衝突) ---
  let tsX = 0;
  document.addEventListener('touchstart', e => {
    // 如果正在放大（scale > 1.05），禁用翻頁手勢，讓用戶可以自由移動看文字
    if (window.visualViewport && window.visualViewport.scale > 1.05) return;
    tsX = e.touches[0].clientX;
  }, {passive: true});

  document.addEventListener('touchend', e => {
    if (isEditMode) return;
    if (window.visualViewport && window.visualViewport.scale > 1.05) return;
    
    const teX = e.changedTouches[0].clientX;
    const delta = tsX - teX;

    if (Math.abs(delta) > 80) {
      if (delta > 0 && currentPage < pages.length - 1) currentPage++;
      else if (delta < 0 && currentPage > 0) currentPage--;
      updatePos();
    }
  });

  render();
  setTimeout(syncUI, 100);
</script>

</body>
</html>
